"int nfc_fw_download(struct nfc_dev *dev, const char *firmware_name)\n{\n  int rc = 0;\n\n  pr_debug(\"%s do firmware %s\\n\", dev_name(&dev->dev), firmware_name);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->dev_up) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  if (!dev->ops->fw_download) {\n    rc = -EOPNOTSUPP;\n    goto error;\n  }\n\n  dev->fw_download_in_progress = true;\n  rc = dev->ops->fw_download(dev, firmware_name);\n  if (rc)\n    dev->fw_download_in_progress = false;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\n/**\n * nfc_fw_download_done - inform that a firmware download was completed\n *\n * @dev: The nfc device to which firmware was downloaded\n * @firmware_name: The firmware filename\n * @result: The positive value of a standard errno value\n */\nint nfc_fw_download_done(struct nfc_dev *dev, const char *firmware_name,\n       u32 result)\n{\n  dev->fw_download_in_progress = false;\n\n  return nfc_genl_fw_download_done(dev, firmware_name, result);\n}\nEXPORT_SYMBOL(nfc_fw_download_done);\n\n/**\n * nfc_dev_up - turn on the NFC device\n *\n * @dev: The nfc device to be turned on\n *\n * The device remains up until the nfc_dev_down function is called.\n */\nint nfc_dev_up(struct nfc_dev *dev)\n{\n  int rc = 0;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  device_lock(&dev->dev);\n\n  if (dev->rfkill && rfkill_blocked(dev->rfkill)) {\n    rc = -ERFKILL;\n    goto error;\n  }\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->fw_download_in_progress) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  if (dev->dev_up) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  if (dev->ops->dev_up)\n    rc = dev->ops->dev_up(dev);\n\n  if (!rc)\n    dev->dev_up = true;\n\n  /* We have to enable the device before discovering SEs */\n  if (dev->ops->discover_se && dev->ops->discover_se(dev))\n    pr_err(\"SE discovery failed\\n\");\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\n/**\n * nfc_dev_down - turn off the NFC device\n *\n * @dev: The nfc device to be turned off\n */\nint nfc_dev_down(struct nfc_dev *dev)\n{\n  int rc = 0;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->dev_up) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  if (dev->polling || dev->active_target) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  if (dev->ops->dev_down)\n    dev->ops->dev_down(dev);\n\n  dev->dev_up = false;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nstatic int nfc_rfkill_set_block(void *data, bool blocked)\n{\n  struct nfc_dev *dev = data;\n\n  pr_debug(\"%s blocked %d\", dev_name(&dev->dev), blocked);\n\n  if (!blocked)\n    return 0;\n\n  nfc_dev_down(dev);\n\n  return 0;\n}\n\nstatic const struct rfkill_ops nfc_rfkill_ops = {\n  .set_block = nfc_rfkill_set_block,\n};\n\n/**\n * nfc_start_poll - start polling for nfc targets\n *\n * @dev: The nfc device that must start polling\n * @protocols: bitset of nfc protocols that must be used for polling\n *\n * The device remains polling for targets until a target is found or\n * the nfc_stop_poll function is called.\n */\nint nfc_start_poll(struct nfc_dev *dev, u32 im_protocols, u32 tm_protocols)\n{\n  int rc;\n\n  pr_debug(\"dev_name %s initiator protocols 0x%x target protocols 0x%x\\n\",\n     dev_name(&dev->dev), im_protocols, tm_protocols);\n\n  if (!im_protocols && !tm_protocols)\n    return -EINVAL;\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->dev_up) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->polling) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  rc = dev->ops->start_poll(dev, im_protocols, tm_protocols);\n  if (!rc) {\n    dev->polling = true;\n    dev->rf_mode = NFC_RF_NONE;\n  }\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\n/**\n * nfc_stop_poll - stop polling for nfc targets\n *\n * @dev: The nfc device that must stop polling\n */\nint nfc_stop_poll(struct nfc_dev *dev)\n{\n  int rc = 0;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->polling) {\n    rc = -EINVAL;\n    goto error;\n  }\n\n  dev->ops->stop_poll(dev);\n  dev->polling = false;\n  dev->rf_mode = NFC_RF_NONE;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nstatic struct nfc_target *nfc_find_target(struct nfc_dev *dev, u32 target_idx)\n{\n  int i;\n\n  for (i = 0; i < dev->n_targets; i++) {\n    if (dev->targets[i].idx == target_idx)\n      return &dev->targets[i];\n  }\n\n  return NULL;\n}\n\nint nfc_dep_link_up(struct nfc_dev *dev, int target_index, u8 comm_mode)\n{\n  int rc = 0;\n  u8 *gb;\n  size_t gb_len;\n  struct nfc_target *target;\n\n  pr_debug(\"dev_name=%s comm %d\\n\", dev_name(&dev->dev), comm_mode);\n\n  if (!dev->ops->dep_link_up)\n    return -EOPNOTSUPP;\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->dep_link_up == true) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  gb = nfc_llcp_general_bytes(dev, &gb_len);\n  if (gb_len > NFC_MAX_GT_LEN) {\n    rc = -EINVAL;\n    goto error;\n  }\n\n  target = nfc_find_target(dev, target_index);\n  if (target == NULL) {\n    rc = -ENOTCONN;\n    goto error;\n  }\n\n  rc = dev->ops->dep_link_up(dev, target, comm_mode, gb, gb_len);\n  if (!rc) {\n    dev->active_target = target;\n    dev->rf_mode = NFC_RF_INITIATOR;\n  }\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nint nfc_dep_link_down(struct nfc_dev *dev)\n{\n  int rc = 0;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  if (!dev->ops->dep_link_down)\n    return -EOPNOTSUPP;\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->dep_link_up == false) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  rc = dev->ops->dep_link_down(dev);\n  if (!rc) {\n    dev->dep_link_up = false;\n    dev->active_target = NULL;\n    dev->rf_mode = NFC_RF_NONE;\n    nfc_llcp_mac_is_down(dev);\n    nfc_genl_dep_link_down_event(dev);\n  }\n\nerror:\n  device_unlock(&dev->dev);\n\n  return rc;\n}\n\nint nfc_dep_link_is_up(struct nfc_dev *dev, u32 target_idx,\n           u8 comm_mode, u8 rf_mode)\n{\n  dev->dep_link_up = true;\n\n  if (!dev->active_target && rf_mode == NFC_RF_INITIATOR) {\n    struct nfc_target *target;\n\n    target = nfc_find_target(dev, target_idx);\n    if (target == NULL)\n      return -ENOTCONN;\n\n    dev->active_target = target;\n  }\n\n  dev->polling = false;\n  dev->rf_mode = rf_mode;\n\n  nfc_llcp_mac_is_up(dev, target_idx, comm_mode, rf_mode);\n\n  return nfc_genl_dep_link_up_event(dev, target_idx, comm_mode, rf_mode);\n}\nEXPORT_SYMBOL(nfc_dep_link_is_up);\n\n/**\n * nfc_activate_target - prepare the target for data exchange\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be activated\n * @protocol: nfc protocol that will be used for data exchange\n */\nint nfc_activate_target(struct nfc_dev *dev, u32 target_idx, u32 protocol)\n{\n  int rc;\n  struct nfc_target *target;\n\n  pr_debug(\"dev_name=%s target_idx=%u protocol=%u\\n\",\n     dev_name(&dev->dev), target_idx, protocol);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->active_target) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  target = nfc_find_target(dev, target_idx);\n  if (target == NULL) {\n    rc = -ENOTCONN;\n    goto error;\n  }\n\n  rc = dev->ops->activate_target(dev, target, protocol);\n  if (!rc) {\n    dev->active_target = target;\n    dev->rf_mode = NFC_RF_INITIATOR;\n\n    if (dev->ops->check_presence && !dev->shutting_down)\n      mod_timer(&dev->check_pres_timer, jiffies +\n          msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n  }\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\n/**\n * nfc_deactivate_target - deactivate a nfc target\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target that must be deactivated\n */\nint nfc_deactivate_target(struct nfc_dev *dev, u32 target_idx)\n{\n  int rc = 0;\n\n  pr_debug(\"dev_name=%s target_idx=%u\\n\",\n     dev_name(&dev->dev), target_idx);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->active_target == NULL) {\n    rc = -ENOTCONN;\n    goto error;\n  }\n\n  if (dev->active_target->idx != target_idx) {\n    rc = -ENOTCONN;\n    goto error;\n  }\n\n  if (dev->ops->check_presence)\n    del_timer_sync(&dev->check_pres_timer);\n\n  dev->ops->deactivate_target(dev, dev->active_target);\n  dev->active_target = NULL;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\n/**\n * nfc_data_exchange - transceive data\n *\n * @dev: The nfc device that found the target\n * @target_idx: index of the target\n * @skb: data to be sent\n * @cb: callback called when the response is received\n * @cb_context: parameter for the callback function\n *\n * The user must wait for the callback before calling this function again.\n */\nint nfc_data_exchange(struct nfc_dev *dev, u32 target_idx, struct sk_buff *skb,\n          data_exchange_cb_t cb, void *cb_context)\n{\n  int rc;\n\n  pr_debug(\"dev_name=%s target_idx=%u skb->len=%u\\n\",\n     dev_name(&dev->dev), target_idx, skb->len);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    kfree_skb(skb);\n    goto error;\n  }\n\n  if (dev->rf_mode == NFC_RF_INITIATOR && dev->active_target != NULL) {\n    if (dev->active_target->idx != target_idx) {\n      rc = -EADDRNOTAVAIL;\n      kfree_skb(skb);\n      goto error;\n    }\n\n    if (dev->ops->check_presence)\n      del_timer_sync(&dev->check_pres_timer);\n\n    rc = dev->ops->im_transceive(dev, dev->active_target, skb, cb,\n               cb_context);\n\n    if (!rc && dev->ops->check_presence && !dev->shutting_down)\n      mod_timer(&dev->check_pres_timer, jiffies +\n          msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n  } else if (dev->rf_mode == NFC_RF_TARGET && dev->ops->tm_send != NULL) {\n    rc = dev->ops->tm_send(dev, skb);\n  } else {\n    rc = -ENOTCONN;\n    kfree_skb(skb);\n    goto error;\n  }\n\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nstruct nfc_se *nfc_find_se(struct nfc_dev *dev, u32 se_idx)\n{\n  struct nfc_se *se;\n\n  list_for_each_entry(se, &dev->secure_elements, list)\n    if (se->idx == se_idx)\n      return se;\n\n  return NULL;\n}\nEXPORT_SYMBOL(nfc_find_se);\n\nint nfc_enable_se(struct nfc_dev *dev, u32 se_idx)\n{\n  struct nfc_se *se;\n  int rc;\n\n  pr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->dev_up) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (dev->polling) {\n    rc = -EBUSY;\n    goto error;\n  }\n\n  if (!dev->ops->enable_se || !dev->ops->disable_se) {\n    rc = -EOPNOTSUPP;\n    goto error;\n  }\n\n  se = nfc_find_se(dev, se_idx);\n  if (!se) {\n    rc = -EINVAL;\n    goto error;\n  }\n\n  if (se->state == NFC_SE_ENABLED) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  rc = dev->ops->enable_se(dev, se_idx);\n  if (rc >= 0)\n    se->state = NFC_SE_ENABLED;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nint nfc_disable_se(struct nfc_dev *dev, u32 se_idx)\n{\n  struct nfc_se *se;\n  int rc;\n\n  pr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n  device_lock(&dev->dev);\n\n  if (!device_is_registered(&dev->dev)) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->dev_up) {\n    rc = -ENODEV;\n    goto error;\n  }\n\n  if (!dev->ops->enable_se || !dev->ops->disable_se) {\n    rc = -EOPNOTSUPP;\n    goto error;\n  }\n\n  se = nfc_find_se(dev, se_idx);\n  if (!se) {\n    rc = -EINVAL;\n    goto error;\n  }\n\n  if (se->state == NFC_SE_DISABLED) {\n    rc = -EALREADY;\n    goto error;\n  }\n\n  rc = dev->ops->disable_se(dev, se_idx);\n  if (rc >= 0)\n    se->state = NFC_SE_DISABLED;\n\nerror:\n  device_unlock(&dev->dev);\n  return rc;\n}\n\nint nfc_set_remote_general_bytes(struct nfc_dev *dev, u8 *gb, u8 gb_len)\n{\n  pr_debug(\"dev_name=%s gb_len=%d\\n\", dev_name(&dev->dev), gb_len);\n\n  return nfc_llcp_set_remote_gb(dev, gb, gb_len);\n}\nEXPORT_SYMBOL(nfc_set_remote_general_bytes);\n\nu8 *nfc_get_local_general_bytes(struct nfc_dev *dev, size_t *gb_len)\n{\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  return nfc_llcp_general_bytes(dev, gb_len);\n}\nEXPORT_SYMBOL(nfc_get_local_general_bytes);\n\nint nfc_tm_data_received(struct nfc_dev *dev, struct sk_buff *skb)\n{\n  /* Only LLCP target mode for now */\n  if (dev->dep_link_up == false) {\n    kfree_skb(skb);\n    return -ENOLINK;\n  }\n\n  return nfc_llcp_data_received(dev, skb);\n}\nEXPORT_SYMBOL(nfc_tm_data_received);\n\nint nfc_tm_activated(struct nfc_dev *dev, u32 protocol, u8 comm_mode,\n         u8 *gb, size_t gb_len)\n{\n  int rc;\n\n  device_lock(&dev->dev);\n\n  dev->polling = false;\n\n  if (gb != NULL) {\n    rc = nfc_set_remote_general_bytes(dev, gb, gb_len);\n    if (rc < 0)\n      goto out;\n  }\n\n  dev->rf_mode = NFC_RF_TARGET;\n\n  if (protocol == NFC_PROTO_NFC_DEP_MASK)\n    nfc_dep_link_is_up(dev, 0, comm_mode, NFC_RF_TARGET);\n\n  rc = nfc_genl_tm_activated(dev, protocol);\n\nout:\n  device_unlock(&dev->dev);\n\n  return rc;\n}\nEXPORT_SYMBOL(nfc_tm_activated);\n\nint nfc_tm_deactivated(struct nfc_dev *dev)\n{\n  dev->dep_link_up = false;\n  dev->rf_mode = NFC_RF_NONE;\n\n  return nfc_genl_tm_deactivated(dev);\n}\nEXPORT_SYMBOL(nfc_tm_deactivated);\n\n/**\n * nfc_alloc_send_skb - allocate a skb for data exchange responses\n *\n * @size: size to allocate\n * @gfp: gfp flags\n */\nstruct sk_buff *nfc_alloc_send_skb(struct nfc_dev *dev, struct sock *sk,\n           unsigned int flags, unsigned int size,\n           unsigned int *err)\n{\n  struct sk_buff *skb;\n  unsigned int total_size;\n\n  total_size = size +\n    dev->tx_headroom + dev->tx_tailroom + NFC_HEADER_SIZE;\n\n  skb = sock_alloc_send_skb(sk, total_size, flags & MSG_DONTWAIT, err);\n  if (skb)\n    skb_reserve(skb, dev->tx_headroom + NFC_HEADER_SIZE);\n\n  return skb;\n}\n\n/**\n * nfc_alloc_recv_skb - allocate a skb for data exchange responses\n *\n * @size: size to allocate\n * @gfp: gfp flags\n */\nstruct sk_buff *nfc_alloc_recv_skb(unsigned int size, gfp_t gfp)\n{\n  struct sk_buff *skb;\n  unsigned int total_size;\n\n  total_size = size + 1;\n  skb = alloc_skb(total_size, gfp);\n\n  if (skb)\n    skb_reserve(skb, 1);\n\n  return skb;\n}\nEXPORT_SYMBOL(nfc_alloc_recv_skb);\n\n/**\n * nfc_targets_found - inform that targets were found\n *\n * @dev: The nfc device that found the targets\n * @targets: array of nfc targets found\n * @ntargets: targets array size\n *\n * The device driver must call this function when one or many nfc targets\n * are found. After calling this function, the device driver must stop\n * polling for targets.\n * NOTE: This function can be called with targets=NULL and n_targets=0 to\n * notify a driver error, meaning that the polling operation cannot complete.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_targets_found(struct nfc_dev *dev,\n          struct nfc_target *targets, int n_targets)\n{\n  int i;\n\n  pr_debug(\"dev_name=%s n_targets=%d\\n\", dev_name(&dev->dev), n_targets);\n\n  for (i = 0; i < n_targets; i++)\n    targets[i].idx = dev->target_next_idx++;\n\n  device_lock(&dev->dev);\n\n  if (dev->polling == false) {\n    device_unlock(&dev->dev);\n    return 0;\n  }\n\n  dev->polling = false;\n\n  dev->targets_generation++;\n\n  kfree(dev->targets);\n  dev->targets = NULL;\n\n  if (targets) {\n    dev->targets = kmemdup(targets,\n               n_targets * sizeof(struct nfc_target),\n               GFP_ATOMIC);\n\n    if (!dev->targets) {\n      dev->n_targets = 0;\n      device_unlock(&dev->dev);\n      return -ENOMEM;\n    }\n  }\n\n  dev->n_targets = n_targets;\n  device_unlock(&dev->dev);\n\n  nfc_genl_targets_found(dev);\n\n  return 0;\n}\nEXPORT_SYMBOL(nfc_targets_found);\n\n/**\n * nfc_target_lost - inform that an activated target went out of field\n *\n * @dev: The nfc device that had the activated target in field\n * @target_idx: the nfc index of the target\n *\n * The device driver must call this function when the activated target\n * goes out of the field.\n * IMPORTANT: this function must not be called from an atomic context.\n * In addition, it must also not be called from a context that would prevent\n * the NFC Core to call other nfc ops entry point concurrently.\n */\nint nfc_target_lost(struct nfc_dev *dev, u32 target_idx)\n{\n  struct nfc_target *tg;\n  int i;\n\n  pr_debug(\"dev_name %s n_target %d\\n\", dev_name(&dev->dev), target_idx);\n\n  device_lock(&dev->dev);\n\n  for (i = 0; i < dev->n_targets; i++) {\n    tg = &dev->targets[i];\n    if (tg->idx == target_idx)\n      break;\n  }\n\n  if (i == dev->n_targets) {\n    device_unlock(&dev->dev);\n    return -EINVAL;\n  }\n\n  dev->targets_generation++;\n  dev->n_targets--;\n  dev->active_target = NULL;\n\n  if (dev->n_targets) {\n    memcpy(&dev->targets[i], &dev->targets[i + 1],\n           (dev->n_targets - i) * sizeof(struct nfc_target));\n  } else {\n    kfree(dev->targets);\n    dev->targets = NULL;\n  }\n\n  device_unlock(&dev->dev);\n\n  nfc_genl_target_lost(dev, target_idx);\n\n  return 0;\n}\nEXPORT_SYMBOL(nfc_target_lost);\n\ninline void nfc_driver_failure(struct nfc_dev *dev, int err)\n{\n  nfc_targets_found(dev, NULL, 0);\n}\nEXPORT_SYMBOL(nfc_driver_failure);\n\nint nfc_add_se(struct nfc_dev *dev, u32 se_idx, u16 type)\n{\n  struct nfc_se *se;\n  int rc;\n\n  pr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n  se = nfc_find_se(dev, se_idx);\n  if (se)\n    return -EALREADY;\n\n  se = kzalloc(sizeof(struct nfc_se), GFP_KERNEL);\n  if (!se)\n    return -ENOMEM;\n\n  se->idx = se_idx;\n  se->type = type;\n  se->state = NFC_SE_DISABLED;\n  INIT_LIST_HEAD(&se->list);\n\n  list_add(&se->list, &dev->secure_elements);\n\n  rc = nfc_genl_se_added(dev, se_idx, type);\n  if (rc < 0) {\n    list_del(&se->list);\n    kfree(se);\n\n    return rc;\n  }\n\n  return 0;\n}\nEXPORT_SYMBOL(nfc_add_se);\n\nint nfc_remove_se(struct nfc_dev *dev, u32 se_idx)\n{\n  struct nfc_se *se, *n;\n  int rc;\n\n  pr_debug(\"%s se index %d\\n\", dev_name(&dev->dev), se_idx);\n\n  list_for_each_entry_safe(se, n, &dev->secure_elements, list)\n    if (se->idx == se_idx) {\n      rc = nfc_genl_se_removed(dev, se_idx);\n      if (rc < 0)\n        return rc;\n\n      list_del(&se->list);\n      kfree(se);\n\n      return 0;\n    }\n\n  return -EINVAL;\n}\nEXPORT_SYMBOL(nfc_remove_se);\n\nint nfc_se_transaction(struct nfc_dev *dev, u8 se_idx,\n           struct nfc_evt_transaction *evt_transaction)\n{\n  int rc;\n\n  pr_debug(\"transaction: %x\\n\", se_idx);\n\n  device_lock(&dev->dev);\n\n  if (!evt_transaction) {\n    rc = -EPROTO;\n    goto out;\n  }\n\n  rc = nfc_genl_se_transaction(dev, se_idx, evt_transaction);\nout:\n  device_unlock(&dev->dev);\n  return rc;\n}\nEXPORT_SYMBOL(nfc_se_transaction);\n\nstatic void nfc_release(struct device *d)\n{\n  struct nfc_dev *dev = to_nfc_dev(d);\n  struct nfc_se *se, *n;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  nfc_genl_data_exit(&dev->genl_data);\n  kfree(dev->targets);\n\n  list_for_each_entry_safe(se, n, &dev->secure_elements, list) {\n      nfc_genl_se_removed(dev, se->idx);\n      list_del(&se->list);\n      kfree(se);\n  }\n\n  kfree(dev);\n}\n\nstatic void nfc_check_pres_work(struct work_struct *work)\n{\n  struct nfc_dev *dev = container_of(work, struct nfc_dev,\n             check_pres_work);\n  int rc;\n\n  device_lock(&dev->dev);\n\n  if (dev->active_target && timer_pending(&dev->check_pres_timer) == 0) {\n    rc = dev->ops->check_presence(dev, dev->active_target);\n    if (rc == -EOPNOTSUPP)\n      goto exit;\n    if (rc) {\n      u32 active_target_idx = dev->active_target->idx;\n      device_unlock(&dev->dev);\n      nfc_target_lost(dev, active_target_idx);\n      return;\n    }\n\n    if (!dev->shutting_down)\n      mod_timer(&dev->check_pres_timer, jiffies +\n          msecs_to_jiffies(NFC_CHECK_PRES_FREQ_MS));\n  }\n\nexit:\n  device_unlock(&dev->dev);\n}\n\nstatic void nfc_check_pres_timeout(unsigned long data)\n{\n  struct nfc_dev *dev = (struct nfc_dev *)data;\n\n  schedule_work(&dev->check_pres_work);\n}\n\nstruct class nfc_class = {\n  .name = \"nfc\",\n  .dev_release = nfc_release,\n};\nEXPORT_SYMBOL(nfc_class);\n\nstatic int match_idx(struct device *d, const void *data)\n{\n  struct nfc_dev *dev = to_nfc_dev(d);\n  const unsigned int *idx = data;\n\n  return dev->idx == *idx;\n}\n\nstruct nfc_dev *nfc_get_device(unsigned int idx)\n{\n  struct device *d;\n\n  d = class_find_device(&nfc_class, NULL, &idx, match_idx);\n  if (!d)\n    return NULL;\n\n  return to_nfc_dev(d);\n}\n\n/**\n * nfc_allocate_device - allocate a new nfc device\n *\n * @ops: device operations\n * @supported_protocols: NFC protocols supported by the device\n */\nstruct nfc_dev *nfc_allocate_device(struct nfc_ops *ops,\n            u32 supported_protocols,\n            int tx_headroom, int tx_tailroom)\n{\n  struct nfc_dev *dev;\n\n  if (!ops->start_poll || !ops->stop_poll || !ops->activate_target ||\n      !ops->deactivate_target || !ops->im_transceive)\n    return NULL;\n\n  if (!supported_protocols)\n    return NULL;\n\n  dev = kzalloc(sizeof(struct nfc_dev), GFP_KERNEL);\n  if (!dev)\n    return NULL;\n\n  dev->ops = ops;\n  dev->supported_protocols = supported_protocols;\n  dev->tx_headroom = tx_headroom;\n  dev->tx_tailroom = tx_tailroom;\n  INIT_LIST_HEAD(&dev->secure_elements);\n\n  nfc_genl_data_init(&dev->genl_data);\n\n  dev->rf_mode = NFC_RF_NONE;\n\n  /* first generation must not be 0 */\n  dev->targets_generation = 1;\n\n  if (ops->check_presence) {\n    init_timer(&dev->check_pres_timer);\n    dev->check_pres_timer.data = (unsigned long)dev;\n    dev->check_pres_timer.function = nfc_check_pres_timeout;\n\n    INIT_WORK(&dev->check_pres_work, nfc_check_pres_work);\n  }\n\n  return dev;\n}\nEXPORT_SYMBOL(nfc_allocate_device);\n\n/**\n * nfc_register_device - register a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to register\n */\nint nfc_register_device(struct nfc_dev *dev)\n{\n  int rc;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  dev->idx = ida_simple_get(&nfc_index_ida, 0, 0, GFP_KERNEL);\n  if (dev->idx < 0)\n    return dev->idx;\n\n  dev->dev.class = &nfc_class;\n  dev_set_name(&dev->dev, \"nfc%d\", dev->idx);\n  device_initialize(&dev->dev);\n\n  mutex_lock(&nfc_devlist_mutex);\n  nfc_devlist_generation++;\n  rc = device_add(&dev->dev);\n  mutex_unlock(&nfc_devlist_mutex);\n\n  if (rc < 0)\n    return rc;\n\n  rc = nfc_llcp_register_device(dev);\n  if (rc)\n    pr_err(\"Could not register llcp device\\n\");\n\n  rc = nfc_genl_device_added(dev);\n  if (rc)\n    pr_debug(\"The userspace won't be notified that the device %s was added\\n\",\n       dev_name(&dev->dev));\n\n  dev->rfkill = rfkill_alloc(dev_name(&dev->dev), &dev->dev,\n           RFKILL_TYPE_NFC, &nfc_rfkill_ops, dev);\n  if (dev->rfkill) {\n    if (rfkill_register(dev->rfkill) < 0) {\n      rfkill_destroy(dev->rfkill);\n      dev->rfkill = NULL;\n    }\n  }\n\n  return 0;\n}\nEXPORT_SYMBOL(nfc_register_device);\n\n/**\n * nfc_unregister_device - unregister a nfc device in the nfc subsystem\n *\n * @dev: The nfc device to unregister\n */\nvoid nfc_unregister_device(struct nfc_dev *dev)\n{\n  int rc, id;\n\n  pr_debug(\"dev_name=%s\\n\", dev_name(&dev->dev));\n\n  id = dev->idx;\n\n  if (dev->rfkill) {\n    rfkill_unregister(dev->rfkill);\n    rfkill_destroy(dev->rfkill);\n  }\n\n  if (dev->ops->check_presence) {\n    device_lock(&dev->dev);\n    dev->shutting_down = true;\n    device_unlock(&dev->dev);\n    del_timer_sync(&dev->check_pres_timer);\n    cancel_work_sync(&dev->check_pres_work);\n  }\n\n  rc = nfc_genl_device_removed(dev);\n  if (rc)\n    pr_debug(\"The userspace won't be notified that the device %s \"\n       \"was removed\\n\", dev_name(&dev->dev));\n\n  nfc_llcp_unregister_device(dev);\n\n  mutex_lock(&nfc_devlist_mutex);\n  nfc_devlist_generation++;\n  device_del(&dev->dev);\n  mutex_unlock(&nfc_devlist_mutex);\n\n  ida_simple_remove(&nfc_index_ida, id);\n}\nEXPORT_SYMBOL(nfc_unregister_device);\n\nstatic int __init nfc_init(void)\n{\n  int rc;\n\n  pr_info(\"NFC Core ver %s\\n\", VERSION);\n\n  rc = class_register(&nfc_class);\n  if (rc)\n    return rc;\n\n  rc = nfc_genl_init();\n  if (rc)\n    goto err_genl;\n\n  /* the first generation must not be 0 */\n  nfc_devlist_generation = 1;\n\n  rc = rawsock_init();\n  if (rc)\n    goto err_rawsock;\n\n  rc = nfc_llcp_init();\n  if (rc)\n    goto err_llcp_sock;\n\n  rc = af_nfc_init();\n  if (rc)\n    goto err_af_nfc;\n\n  return 0;\n\nerr_af_nfc:\n  nfc_llcp_exit();\nerr_llcp_sock:\n  rawsock_exit();\nerr_rawsock:\n  nfc_genl_exit();\nerr_genl:\n  class_unregister(&nfc_class);\n  return rc;\n}\n\nstatic void __exit nfc_exit(void)\n{\n  af_nfc_exit();\n  nfc_llcp_exit();\n  rawsock_exit();\n  nfc_genl_exit();\n  class_unregister(&nfc_class);\n}\n\nsubsys_initcall(nfc_init);\nmodule_exit(nfc_exit);\n"
